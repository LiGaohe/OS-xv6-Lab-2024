1. 哪些寄存器包含函数的参数？例如，哪个寄存器在main对 printf 的调用中保存13？
通用寄存器a0-a7；根据代码：
```
void main(void) {
  1c:	1141                	addi	sp,sp,-16
  1e:	e406                	sd	ra,8(sp)
  20:	e022                	sd	s0,0(sp)
  22:	0800                	addi	s0,sp,16
  printf("%d %d\n", f(8)+1, 13);
  24:	4635                	li	a2,13
  ...
}
可知a2存放13
```

2. 在main的汇编代码中，对函数 f 的调用在哪里？ g 的调用在哪里？
`main`里没有对`f`或`g`的函数调用。在`main`的汇编里，直接用`li a1,12`把结果算好，说明编译器已经把`f`和`g`的调用都“内联”了（直接展开成加法运算），没有函数跳转。

3. 函数`printf`位于哪个地址？
```
// main中
26:	45b1                	li	a1,12
  28:	00001517          	auipc	a0,0x1
  2c:	84850513          	addi	a0,a0,-1976 # 870 <malloc+0x100>
  30:	68c000ef          	jal	6bc <printf>
  exit(0);
  34:	4501                	li	a0,0
  36:	26e000ef          	jal	2a4 <exit>
```
可知`printf`位于`0x6bc`（此值在不同环境下不同）

4. 在 main 中的 jalr 到 printf 之后，寄存器 ra 中的值是什么？
在 RISC-V 架构下，jalr（或 jal）指令会把“下一条指令的地址”（即当前 PC + 4）存入 ra 寄存器，作为返回地址。

在 main 调用 printf 时，使用的是 jal 指令（不是 jalr），如下：
```
30:	68c000ef          	jal	6bc <printf>
```

执行这条指令时当前 PC 是 0x30，则下一条指令地址是 0x34
所以，ra 寄存器的值就是 0x34

5. 运行以下代码：
```
 无符号整数 i = 0x00646c72;； 
 printf("H%x Wo%s", 57616, (char *) &i);； 
```

输出是什么？ 
输出结果取决于RISC-V是采用小端序这一事实。如果RISC-V改为采用大端序，为了得到相同的输出结果，你应该将i设置为多少？你需要将57616更改为其他值吗？

- 57616 用十六进制输出：e110
i 的内存内容是 0x72 0x6c 0x64 0x00（小端序，低地址在前）
- (char *)&i 作为字符串，会从低地址开始读，直到遇到 \0（0x00）为止。所以字符串内容是：0x72 = 'r', 0x6c = 'l', 0x64 = 'd'，然后遇到 0x00 结束。
即He110 World

- 大端序下，i 的内存布局是 0x00 0x64 0x6c 0x72（高地址在前）
- (char *)&i 读到第一个字节就是 0x00，字符串立刻结束，输出空字符串。要让大端序下输出 "rld"，需要让内存布局变成 0x72 0x6c 0x64 0x00，即：
i = 0x726c6400;
- 由于大端/小端只改变内存布局，而57616 的输出是e110，与字节序无关，直接传给 printf，不会受内存布局影响，因此不需要改变。

6. 在以下代码中，'y='之后会打印出什么？（注意：答案不是一个具体的值。）为什么会这样？ 
printf("x=%d y=%d", 3);
- 'y=' 之后会打印出一个未定义的值（可能是随机数、垃圾值、甚至 0），因为 printf 期望有两个参数（分别对应两个 %d），但只传了一个参数（3）。第二个 %d 会从栈上错误地取一个值。