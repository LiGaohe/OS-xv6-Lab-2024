# Lab: Xv6 and Unix utilities
## 实验目的
    - 熟悉xv6及其系统调用

# 1. 启动 xv6

## 实验目的
    - 设置计算机以运行实验

## 实验步骤
    
    1. 克隆到本地:
        
        在wsl2下执行：
        ```bash
        $ git clone git://g.csail.mit.edu/xv6-labs-2024
        Cloning into 'xv6-labs-2024'

        $ cd xv6-labs-2024
        ```

    2. 尝试运行xv6：
        ```bash
        $ make qemu
        ```

        输出：
        ```bash
        ···
        xv6 kernel is booting

        hart 2 starting
        hart 1 starting
        init: starting sh
        ```

    3. 退出qemu:
    同时按下`Ctrl + a`，再按下`x`.

# 2. sleep
## 实验目的
在 xv6 操作系统中实现一个用户级的 sleep 程序，接受用户指定的时间参数，使进程暂停运行相应的时长。通过此实验，尝试理解 xv6 系统调用机制、用户程序与内核的交互方式，以及命令行参数的处理方法。

## 实验步骤
1. 阅读 xv6 第一章以及user目录下文件

2. 在 xv6 的 user/ 目录下创建 sleep.c 文件。

3. 根据实验要求以及注意事项，程序需要注意：
   - 若参数数量不足，打印错误信息并退出
   - 使用 atoi() 函数将字符串参数转换为整数
   - sleep() 调用返回后，调用 exit(0) 正常退出

4. 在 Makefile 的 UPROGS 变量中添加 sleep 程序，使其能够被编译并加入 xv6 文件系统。

    ```bash
    $U/_sleep\
    ```

5. 使用 make qemu 启动 xv6，键入`sleep`命令测试功能，并使用make grade判断测试是否通过。

## 实验中遇到的问题和解决方法

1. 命令行参数处理错误
   - 解决方法：参考 user/echo.c 的实现，了解argc 表示命令行参数的数量（argument count），包括程序本身的名字；argv 是一个字符串数组（argument vector），输入命令行的每个元素都是一个参数

2. `make qemu`时出现链接错误
   - 解决方法：在`Makefile`的`UPROGS`中添加`$U/_sleep`，确保编译系统能够识别并编译新程序

## 实验心得

1. 通过查阅 user/usys.S 和 kernel/sysproc.c，了解了用户程序通过`ecall`指令引发trap进入内核态，然后内核trap完成实际功能的流程。

2. 学会了如何正确创建用户程序、处理命令行参数、调用系统调用、如何将新程序添加到 xv6 系统中。

# 3. pingpong

## 实验目的
编写一个用户级程序使用 xv6 系统调用在两个进程之间通过管道进行一字节的"乒乓"通信。通过实践加深对进程间通信、管道机制、进程创建等操作系统概念的理解。

## 实验步骤

### 1. 参考 xv6 的 user/ 目录下的 pipe、fork 等示例程序。

### 2. 在`user`目录下新建`pingpong.c`文件。

### 3. 代码实现
- 创建两个管道`parent[2]`和`child[2]`，分别用于父到子、子到父通信。
- 调用 fork() 创建子进程。
- 父进程和子进程各自关闭不需要的管道端口，避免阻塞和资源浪费。
- 父进程向子进程发送一个字节，等待子进程回复。
- 子进程收到字节后，打印 <pid>: received ping，再回复父进程。
- 父进程收到回复后，打印 <pid>: received pong。
- 两个进程均在结束前关闭所有用过的管道端口，并调用 exit(0) 正常退出。

### 4. 修改 Makefile
在 Makefile 的 UPROGS 变量中添加：
```c
$U/_pingpong\
```

### 5. 测试
```c
$ make qemu
$ pingpong
```
输出
```c
4: received ping
3: received pong
```

## 实验中遇到的问题和方法

### 问题1：未正确关闭不需要的管道端，导致程序阻塞。

**解决方法**：根据父子进程各自需要的管道端，在 fork 后关闭不需要的端：
- 由于子进程子进程只需要父到子管道的读端和子到父管道的写端，关闭父到子管道的写端和子到父管道的读端
- 父进程只需要父到子管道的写端和子到父管道的读端，关闭父到子管道的读端和子到父管道的写端

## 实验心得
1. pipe实现的原理是两个进程共用读写的文件描述符，而调用 fork() 创建一个子进程，子进程会继承父进程的文件描述符，包括管道的文件描述符。pipe函数要在fork之前调用，确保只有父进程创建了管道。

1. 通过实现 pingpong 程序，掌握了管道的基本用法，理解了父子进程如何通过管道进行数据交换，以及父进程先写后读、子进程先读后写的阻塞读写机制可实现进程同步。

2. 及时关闭不需要的管道端口可以防止资源泄漏和死锁。


