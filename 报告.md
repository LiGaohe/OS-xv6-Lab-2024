# Lab: Xv6 and Unix utilities
## 实验目的
    - 熟悉xv6及其系统调用

# 1. 启动 xv6

## 实验目的
    - 设置计算机以运行实验

## 实验步骤
    
    1. 克隆到本地:
        
        在wsl2下执行：
        ```bash
        $ git clone git://g.csail.mit.edu/xv6-labs-2024
        Cloning into 'xv6-labs-2024'

        $ cd xv6-labs-2024
        ```

    2. 尝试运行xv6：
        ```bash
        $ make qemu
        ```

        输出：
        ```bash
        ···
        xv6 kernel is booting

        hart 2 starting
        hart 1 starting
        init: starting sh
        ```

    3. 退出qemu:
    同时按下`Ctrl + a`，再按下`x`.

# 2. sleep
## 实验目的
在 xv6 操作系统中实现一个用户级的 sleep 程序，接受用户指定的时间参数，使进程暂停运行相应的时长。通过此实验，尝试理解 xv6 系统调用机制、用户程序与内核的交互方式，以及命令行参数的处理方法。

## 实验步骤
1. 阅读 xv6 第一章以及user目录下文件

2. 在 xv6 的 user/ 目录下创建 sleep.c 文件。

3. 根据实验要求以及注意事项，程序需要注意：
   - 若参数数量不足，打印错误信息并退出
   - 使用 atoi() 函数将字符串参数转换为整数
   - sleep() 调用返回后，调用 exit(0) 正常退出

4. 在 Makefile 的 UPROGS 变量中添加 sleep 程序，使其能够被编译并加入 xv6 文件系统。

    ```bash
    $U/_sleep\
    ```

5. 使用 make qemu 启动 xv6，键入`sleep`命令测试功能，并使用make grade判断测试是否通过。

## 实验中遇到的问题和解决方法

1. 命令行参数处理错误
   - 解决方法：参考 user/echo.c 的实现，了解argc 表示命令行参数的数量（argument count），包括程序本身的名字；argv 是一个字符串数组（argument vector），输入命令行的每个元素都是一个参数

2. `make qemu`时出现链接错误
   - 解决方法：在`Makefile`的`UPROGS`中添加`$U/_sleep`，确保编译系统能够识别并编译新程序

## 实验心得

1. 通过查阅 user/usys.S 和 kernel/sysproc.c，了解了用户程序通过`ecall`指令引发trap进入内核态，然后内核trap完成实际功能的流程。

2. 学会了如何正确创建用户程序、处理命令行参数、调用系统调用、如何将新程序添加到 xv6 系统中。

# 3. pingpong

## 实验目的
编写一个用户级程序使用 xv6 系统调用在两个进程之间通过管道进行一字节的"乒乓"通信。通过实践加深对进程间通信、管道机制、进程创建等操作系统概念的理解。

## 实验步骤

### 1. 参考 xv6 的 user/ 目录下的 pipe、fork 等示例程序。

### 2. 在`user`目录下新建`pingpong.c`文件。

### 3. 代码实现
- 创建两个管道`parent[2]`和`child[2]`，分别用于父到子、子到父通信。
- 调用 fork() 创建子进程。
- 父进程和子进程各自关闭不需要的管道端口，避免阻塞和资源浪费。
- 父进程向子进程发送一个字节，等待子进程回复。
- 子进程收到字节后，打印 <pid>: received ping，再回复父进程。
- 父进程收到回复后，打印 <pid>: received pong。
- 两个进程均在结束前关闭所有用过的管道端口，并调用 exit(0) 正常退出。

### 4. 修改 Makefile
在 Makefile 的 UPROGS 变量中添加：
```c
$U/_pingpong\
```

### 5. 测试
```c
$ make qemu
$ pingpong
```
输出
```c
4: received ping
3: received pong
```

## 实验中遇到的问题和方法

### 问题1：未正确关闭不需要的管道端，导致程序阻塞。

**解决方法**：根据父子进程各自需要的管道端，在 fork 后关闭不需要的端：
- 由于子进程子进程只需要父到子管道的读端和子到父管道的写端，关闭父到子管道的写端和子到父管道的读端
- 父进程只需要父到子管道的写端和子到父管道的读端，关闭父到子管道的读端和子到父管道的写端

## 实验心得

1. 通过实现 pingpong 程序，掌握了管道的基本用法，理解了父子进程如何通过管道进行数据交换，以及父进程先写后读、子进程先读后写的阻塞读写机制可实现进程同步。

2. 及时关闭不需要的管道端口可以防止资源泄漏和死锁。

# 4. primes

## 实验目的
本次实验需要完成一个使用管道和进程协作的并发素数筛选程序。该方案源自Unix管道发明者Doug McIlroy的设计思路，要求在xv6系统中通过创建多个协作进程，构建一个能够高效筛选素数的流水线处理系统。

## 实验步骤
1. 研究基于管道通信的素数筛算法，理解每个素数对应一个独立筛选进程的设计思想:

   - 首个处理进程从左侧管道读取数据，识别出第一个素数并输出
   - 随后为每个新发现的素数创建专属进程，负责过滤该素数的倍数
   - 各进程间通过管道连接，形成连续的数据处理链

2. 主函数 `main()`:
   - 创建初始管道，用于传递 2~280 的整数序列
   - 创建第一个子进程，负责执行筛选逻辑
   - 父进程向管道中写入待筛选的整数序列
   - 写完数据后关闭管道写端，通知下游处理
   - 等待所有子进程完成工作

3. 实现递归筛选函数 `sieve()`:
   - 从输入管道读取第一个数，根据素数筛选法，这必然是素数
   - 打印该素数
   - 创建新管道，用于传递过滤后的数据
   - 创建子进程递归处理下一级筛选
   - 在当前进程中，将不能被当前素数整除的数传递给新管道
   - 注意使用 `__attribute__((noreturn))` 避免编译警告

4. 进程注意事项:
   - 每个筛选进程仅保留必要的管道端口
   - 使用 `close()` 及时关闭不需要的文件描述符
   - 通过检查 `read()` 返回值判断数据流结束
   - 用 `wait()` 确保子进程正常结束

5. 修改`Makefile`：
   ```bash
   $U/_primes\
   ```

6. 运行测试:
   ```bash
   $ make qemu
   $ primes

   // 输出2到280的素数
   ```

   或在qemu外输入:
   ```bash
   $ make GRADEFLAGS=primes grade

   primes: OK (2.9s)
   ```

## 遇到的问题及解决方法
1. xv6系统对进程数量和文件描述符有严格限制，若文件描述符泄漏会导致后续进程无法创建管道
   - 解决方法：实现中只保留必需的文件描述符：

     子进程创建后立即关闭父进程的管道写端：`close(pfd[1])`
     子进程递归调用前关闭不再需要的读端：`close(pfd[0])`
     因为父进程只负责向新创建管道写入数据，关闭该管道的读端，
     数据传输完成后关闭所有剩余管道

2. 需要确保所有衍生进程按正确顺序完成工作，避免子进程提前退出导致管道断裂
   - 解决方法：

     在每个 `sieve()` 函数中使用 `wait(0)` 等待直接子进程结束
     递归使每个进程负责创建和等待下一级筛选进程

5. 无论在哪个分支，函数都通过 `exit(0)` 结束进程，而不是正常返回
   - 解决方法：

     添加`void sieve(int pfd[2]) __attribute__((noreturn))`明确告知编译器此函数不会返回到调用点，消除"控制流到达非void函数末尾"的警告

## 实验心得

   素数筛选实现了流水线（pipeline）处理。每个进程接收上游数据，处理后传递给下游，多个进程可以同时工作。不仅提高了计算效率，还自然地将问题分解为可并行处理的子任务。通过这个实验，我更深入地理解了流水线并发的工作原理和优势。

   `sieve`函数在进程创建递归调用，每个新得到的素数都会创建一个新的筛选进程，而不需要事先确定进程数量。这种方法展示了递归思想在编程中的妙用。

# 5. find

## 实验目的

实现一个简化版的 UNIX find 程序，用于在 xv6 操作系统中递归查找指定目录树下所有与给定文件名匹配的文件。通过本实验，掌握 xv6 文件系统的目录遍历、递归编程方法以及字符串处理技巧。

## 实验步骤

1. 参考 user/ls.c，学习如何读取目录内容。
2. 编写 find 函数:
    - 递归遍历目录树，查找与目标文件名匹配的文件。
    - 在遍历过程中，跳过 "." 和 ".." 目录，避免死循环。
    - 使用 strcmp 进行字符串比较，避免直接用 ==。

核心代码如下：
```c
void find(char *path, char *filename) {
    // 参数：fd表示打开的目录，de用于存储读取的信息，st用于获取文件类型
    char buf[512], *p;
    int fd;
    struct dirent de;
    struct stat st;

    // 错误检查
    if ((fd = open(path, 0)) < 0) {
        fprintf(2, "无法打开目录 %s\n", path);
        return;
    }

    if ((fstat(fd, &st)) < 0) {
        fprintf(2, "无法获取目录 %s 的状态\n", path);
        close(fd);
        return;
    }

    if (st.type != T_DIR) {
        fprintf(2, "%s 不是一个目录\n", path);
        close(fd);
        return;
    }

    if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf) {
        fprintf(2, "路径太长\n");
        close(fd);
        return;
    }

    strcpy(buf, path);
    p = buf + strlen(buf);
    *p++ = '/';

    // 遍历当前目录
    while (read(fd, &de, sizeof(de))) {
        // 跳过无效的目录项，只处理实际存在的文件和目录
        if (de.inum == 0) continue;

        memmove(p, de.name, DIRSIZ);
        p[DIRSIZ] = 0;

        if (stat(buf, &st) < 0) {
            fprintf(2, "无法获取文件 %s 的状态\n", buf);
            continue;
        }

        // 跳过当前目录和父目录
        if (strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0) continue;

        // 文件名匹配
        if (strcmp(de.name, filename) == 0) {
            printf("%s\n", buf);
        }

        // 递归搜索子目录
        if (st.type == T_DIR) {
            find(buf, filename);
        }
    }

    close(fd);
}
```

3. 在 Makefile 的 UPROGS 中添加 find 程序，确保其能被编译进系统。
4. 测试 find 程序功能。
```bash
$ make GRADEFLAGS=find grade

== Test find, in current directory == find, in current directory: OK (2.6s) 
== Test find, in sub-directory == find, in sub-directory: OK (0.4s) 
== Test find, recursive == find, recursive: OK (1.1s)
```

## 实验中遇到的问题和解决方法
1. C 语言中不能用 == 比较字符串，需用 strcmp。
    - 解决方法：

        查阅后，改用 strcmp 进行文件名匹配。

2. 在递归进入子目录时，需正确拼接路径。
    - 解决方法:

        通过缓冲区和指针操作，确保路径格式正确，且不越界。

3. 多次测试后，文件系统中产生了多余文件。
    - 解决方法：
        通过 make clean 和 make qemu 重新初始化文件系统，保证测试环境干净。

# 实验心得
通过本次实验，深入理解了 xv6 文件系统的目录结构和遍历方法:


    xv6 文件系统采用类 Unix 的层次化目录结构，根目录为 /，其下可以有多个子目录和文件。每个目录本质上是一个特殊的文件，包含若干目录项（dirent），每个目录项记录了文件名和 inode 编号。


    1. 打开目录：使用 open() 打开目录，获取文件描述符。
    2. 读取目录项：用 read() 逐个读取 struct dirent 结构体，获取每个文件/子目录的名字和 inode。
    3. 跳过无效项：如果 dirent.inum == 0，说明该项无效，需跳过。
    跳过特殊目录：目录中总有 "."（当前目录）和 ".."（父目录），遍历时要跳过它们，避免递归死循环。
    4. 拼接路径：对子目录递归时，需要将当前路径与子目录名拼接，形成新的完整路径。
    5. 判断类型：用 stat() 获取路径对应的 stat 结构体，判断是普通文件还是目录。只有目录才递归。
    6. 递归遍历：对子目录递归调用遍历函数，实现整个目录树的遍历。


# 6. xargs

## 实验目的
实现一个简化版的 UNIX xargs 程序，在 xv6 操作系统中实现命令参数的自动拼接与批量执行。通过本实验，掌握标准输入读取、命令行参数拼接、进程创建与管理（fork/exec/wait）等操作系统基本机制。

## 实验步骤
1. 阅读实验要求，理解 xargs 的工作原理：
    - 读取标准输入的每一行，将其作为参数追加到命令后面，然后执行该命令。
2. 代码实现：
    - 复制命令行参数到 argv 数组备用。
    - 逐行读取标准输入（以 \n 结尾），每行作为新参数追加到命令后。
    - 用 fork 创建子进程，子进程用 exec 执行拼接后的命令。
    - 父进程用 wait 等待子进程结束。
    - 注意参数数量不能超过 MAXARG。
4. 在 Makefile 的 UPROGS 变量中添加 xargs。
5. 编译并测试：
    ```bash
    $ echo hello too | xargs echo bye
    bye hello too
    ```

## 实验中遇到的问题和解决方法
1. 不知道如何正确读取标准输入并分割参数：
    - 解决方法：参考 user/echo.c 的参数处理方式，使用 read(0, &c, 1) 逐字符读取，遇到空格或换行分割参数。
2. exec 参数数组溢出：
    - 解决方法：查阅 kernel/param.h，确保参数总数不超过 MAXARG。

## 实验心得
- 管道可将前一个进程的输出作为下一进程的输入，但很多命令不接收管道的传递方式（如echo），其不能直接接收标准输入，而需要接收命令行参数。
此时需要使用`xargs`命令将管道传输过来的stdin进行处理，然后传递到命令的参数位上。即xargs指令执行: 处理管道左侧的标准输入以及处理后传递到正确的位置上。如果不加xargs指令，则echo命令会提示缺少操作参数。

- xargs命令其实是将管道的标准输入与命令参数拼接为一个新命令行参数。其从输入中读取字符串，直到遇到 \n 或 \r 则停止， 然后将所有读取参数放在一个字符串数组里，将每一行都作为一个参数 fork 出一个子进程来执行 exec 系统调用。

---

# Lab: System Call
## system call tracing

